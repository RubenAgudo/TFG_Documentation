\chapter{Desarrollo}

\section{Qu\'{e} se ha hecho}
Se ha desarrollado una aplicaci\'{o}n que dados unos datos organizados
de una determinada manera permite la visualizaci\'{o}n de los mismos y
la selecci\'{o}n de unos rangos para guardar y determinar que en ese rango de tiempo
est\'{a} sucediendo una acci\'{o}n determinada, ya sea un Paso o una Situaci\'on.

Los datos de entrada representan Observaciones y Propiedades. Cada observaci\'{o}n tiene una serie
de propiedades que son las que se visualizan. Estos datos, cuando fueron capturados, puede
que tengan uno o varios v\'{i}deos asociados. La visualizaci\'{o}n de los v\'{i}deos es completamente
optativa, y en caso de visualizarlos, van sincronizados con los gr\'{a}ficos a partir del instante que el 
usuario diga.

Es decir, en cada gr\'{a}fico habr\'{a} una l\'{i}nea de progreso para que sea f\'{a}cil determinar en que ciclo
de simulaci\'{o}n estamos \footnote{Un ciclo de simulaci\'{o}n es la unidad de tiempo elegida para la captura de datos, no
    necesariamente es un segundo.}.

Una vez hemos determinado cual es el problema ha resolver, se hace necesario tomar ciertas decisiones.
Desde un principio se sab\'ia que hab\'ia que programar en un entorno Windows, utilizando Visual Studio 2013.
La raz\'on de esta decisi\'on fue que el proyecto actual est\'a desarrollado utilizando Windows Forms, y el 
director del proyecto coment\'o que exist\'ia una intenci\'on de portarlo a WPF.

Pese a conocer a esa intenci\'on, hubo que valorar que merec\'ia mas la pena, si utilizar WPF, una tecnolog\'ia moderna
en la que Microsoft est\'a poniendo todo su empe\~no, o bien Windows Forms, que es un viejo conocido del desarrollo
.NET con un camino muy largo de desarrollo.

Para decidir de la manera mas objetiva posible, se confeccion\'o la tabla \ref{ComparativaWPF} en la que se sit\'uan 
las caracter\'isticas de cada tecnolog\'ia. La tabla es una elaboraci\'on propia confeccionada a partir de una comparativa
online \cite{WPFvsWinForms:Comparative}.

\begin{table}[H]
	\begin{center}
		\rowcolors{1}{lightgray}{} %\rowcolors{<starting row index>}{<odd row color>}{<even row color>}
		\begin{tabular}{|p{5cm} | p{4cm} | p{4cm}|}
			\rowcolor{darkgray}                         & \color{white}Windows Forms               & \color{white}WPF \\
			Formularios y controles                     & Si                                       & Si \\
			Documentos en pantalla                      & Si                                       & Si \\
			Documentos de formato fijo (XPS, PDF)       & No                                       & Si \\
			Im\'{a}genes                                & No                                       & Si \\
			V\'{i}deo y audio                           & No                                       & Si \\
			Gr\'{a}ficos 2D                             & No                                       & Si \\
			Gr\'{a}ficos 3D                             & No                                       & Si \\
			Interfaz compatible con altas resoluciones  & No, basada en BMP                        & Si, basada en vectores \\
			Creaci\'{o}n de la interfaz                 & Arrastrando y soltando los elementos     & Interfaz declarativa tipo XML \\
			Multilenguaje                               & Mediante archivos de recursos, f\'{a}cil y bien documentado & Mediante DLLs sat\'{e}lite, poco documentado y las herramientas aun no est\'{a}n listas para un entorno de producci\'{o}n. \\
			\hline
		\end{tabular}
	\end{center}
	\caption[Comparativa Windows Forms y WPF]{Comparativa Windows Forms y WPF}
	\label{ComparativaWPF}
\end{table}

C\'omo puede observarse, Windows Forms se ha quedado obsoleto para un desarrollo de aplicaciones moderno.
Pese a todo, WPF, tiene algunos puntos d\'ebiles. Entre ellos, el soporte multilenguaje, y que es un proyecto
mucho menos maduro, ya que fue lanzado en 2006 junto con .NET Framework 3 \cite{WPF:Overview}. Windows Forms,
por su parte se present\'o junto con la primera version de .NET Framework, en 2002.

Esta elecci\'on condiciona el resto de decisiones que fueron tomadas, ya que las bibliotecas gr\'aficas
de Windows Forms no son compatibles con WPF. Existe una capa de compatibilidad en la que es posible embeber dentro
de un host WPF un control Windows Forms, pero no es recomendable, ya que no deja de ser una capa de compatibilidad y
no es posible sacarle toda la potencia a Windows Presentation Foundation.

Una de las primeras decisiones que se tomaron, y adem\'as sin demasiado debate, fue que tipo de interfaz se deseaba.
Se eligi\'o una interfaz tipo IDE, con ventanas acoplables, tal y como se ha detallado en el cap\'itulo de Antecedentes.

En este caso en concreto no hubo mucho donde buscar, ya que no hay mucho donde elegir. La biblioteca seleccionada
fue AvalonDock.

AvalonDock es una biblioteca escrita \'integramente para WPF, con soporte para MVVM. Permite todo lo que se espera
de un proyecto como es: Ventanas acoplables a los lados, mover pesta\~nas etc. Durante el desarrollo se descubri\'o
un bug en el software.

Dicho bug, lanzaba una excepci\'on cuando un elemento ``acoplable", que ten\'ia un Men\'u superior, al ponerlo
en una pesta\~na, al cambiar de pesta\~na fallaba. El bug ya estaba reportado, pero aun as\'i se le proporcion\'o
al desarrollador mas informaci\'on sobre el bug \footnote{\url{https://avalondock.codeplex.com/discussions/429063}}.

La estructura que se ha dise\~nado es un ``workbench", con un panel lateral en el que se pueden visualizar las observaciones
y propiedades disponibles despu\'es de haber cargado un fichero XML. Cuando se hace doble click sobre un elemento
de ese \'arbol de propiedades y observaciones, el software sabe si se ha pinchado en una propiedad o en una observaci\'on.
Si se quiere saber que sucede cuando se pincha en cada uno de ellos, todo esto est\'a mejor explicado en la secci\'on de
Captura de requisitos, en los casos de uso extendidos.

Cuando se cargan los datos que se desean, se muestran los datos cargados, organizados por observaciones. Y dentro de cada
observaci\'on las propiedades que han sido cargadas. Las ventanas pueden organizarse como se quiera, ponerlas lado a lado,
reordenar las pesta\~nas, colapsarlas a un lateral, dejarlas como ventanas flotantes etc. 
La \'unica limitaci\'on intencionada es que una propiedad no puede acoplarse a una observaci\'on a la que no pertenece,
para evitar confusiones.

Despu\'es de escoger el tipo de organizaci\'on de ventanas, era necesario elegir como iban a mostrarse los gr\'aficos en pantalla.
Para el sistema de gr\'aficos no hubo problemas a la hora de encontrar distintas librer\'ias, pero si que fue un 
problema encontrar uno que cumpliera las siguientes caracter\'isticas.

\begin{itemize}
	\item Permitir mostrar gr\'{a}ficos cont\'{i}nuos y discretos, y estos \'{u}ltimos tanto num\'{e}ricos como por categor\'{i}as.
	\item Permitir la selecci\'{o}n de rangos con el rat\'{o}n.
	\item Permitir mostrar el progreso del v\'{i}deo asociado. Bien sin programar la funci\'{o}n o al menos que fuese f\'{a}cilmente programable.
\end{itemize}

Se descartaron todas las bibliotecas de pago, como pueden ser Telerik, SciChart, Visiblox, etc. por ser demasiado caras
y porque se decidi\'o utilizar en la medida de lo posible tecnolog\'ias libres y gratuitas. Entre las bibliotecas
gratuitas, destacaron tres por encima de todas. Las capacidades nativas de WPF,
WPF toolkit, desarrollada por Microsoft, y OxyPlot.

Los gr\'aficos 2D integrados en WPF son muy simples de utilizar, con una est\'etica muy minimalista, de colores planos.
Lamentablemente, la selecci\'on de rangos, y mostrar leyendas en los ejes X e Y no eran tareas triviales, por lo que
se descart\'o al poco de iniciar el desarrollo.

WPF toolkit fue la siguiente librer\'ia en pasar la prueba. Se integra a la perfecci\'on 
en Visual Studio y muestra unos gr\'aficos muy profesionales de una forma
muy simple, pero desafortunadamente, no existe una manera sencilla de seleccionar un rango.

OxyPlot, por su parte, es un proyecto comunitario en constante desarrollo. Con decenas de ejemplos online en su web
oficial fue muy sencillo crear un prototipo funcional con todos los gr\'aficos requeridos, con las leyendas en los ejes
y los t\'itulos. Conseguir la selecci\'on de un rango conllev\'o algo mas de tiempo de desarrollo, pero finalmente 
se consigui\'o.

En los primeros prototipos, en cada gr\'afico pod\'ia seleccionarse un rango diferente, pero era algo inconsistente, ya
que cuando llegase la hora de guardar los rangos, Â¿Cual se usar\'ia? Por lo que fue necesario continuar un poco con la 
investigaci\'on para ver como podr\'ia un hijo notificar a su padre de que ha cambiado, para que ese padre notifique a todos
sus hijos para sincronizarse.

La primera aproximaci\'on, y posiblemente la peor de todas, era realizar un \emph{polling}, es decir, cada, por ejemplo, 60 ms,
preguntar a sus hijos a ver si han cambiado, y si alguno a cambiado, utilizar ese valor para poner ese rango en los dem\'as 
gr\'aficos. Este enfoque, tiene diversos problemas, pese a que los gr\'aficos est\'an guardados en \'arboles rojo-negro,
no tiene sentido recorrer el \'arbol constantemente, y si se encuentra un elemento, volviendo a recorrer todos. Eso,
conllevar\'ia un coste de \textbf{O(2n)}.

La otra soluci\'on, es implementar la interfaz \emph{INotifyPropertyChanged}. Utilizando esta interfaz, se expone un 
nuevo evento, llamado \emph{PropertyChanged} al que otros objetos se pueden suscribir para estar a la escucha.

De esta manera, cada vez que se a\~nada un nuevo gr\'afico, el contenedor de gr\'aficos se suscribe a ese evento para todos
sus hijos. De esta manera, cuando el rango seleccionado cambie, solo ser\'a ese hijo el que notifique al padre, que iniciar\'a
el proceso de sincronizado, tanto con sus hijos como con sus hermanos (el resto de observaciones cargadas).

Para la visualizaci\'on de v\'ideos no hubo mucho problema, y se utilizaron los
propios componentes de WPF, que cumpl\'ian todas las necesidades.

Otro de los problemas fundamentales que se tuvieron, fue como guardar los datos. Debido a que de momento el software
aqu\'i presentado va a ser completamente independiente, hab\'ia que buscar una manera de compartir los datos
que implicara el menor n\'umero de cambios posibles en el sistema ya creado por el grupo de investigaci\'on.

Se barajaron varias posibilidades, como por ejemplo, las bases de datos relaciones, pero este sistema requerir\'ia
de una estructura compleja para guardar unos datos bastante sencillos. Ya que del modelo de dominio, se saca que m\'inimo,
iba a haber 4 tablas para poder guardar los datos correctamente. Adem\'as, los datos no iban a ser f\'acilmente 
visualizables por humanos, ya que ser\'ian un amasijo de n\'umeros guardados en tablas que ser\'ian dif\'iciles de
relacionar entre de manera sencilla.

Es por ello que se valor\'o la posibilidad de utilizar las bases de datos no relacionales, que est\'an tan de moda
\'ultimamente. Concretamente, la versi\'on sometida a pruebas fue MongoDB. Es una base de datos NO-SQL en la que los
datos se guardan en formato de ``documentos", no tablas. Internamente, se guardan en formato BSON, que no deja de ser
un JSON binario \footnote{Especificaci\'{o}n JSON: \url{http://json.org/}}. Ofrece un gran rendimiento, adem\'as
de unos datos mejor organizados para esta tarea, ya que tienen mas forma de documento, y menos de datos que se
relacionan de una manera cl\'asica. 

Finalmente se opt\'o por descartarlo tambi\'en, ya que a\~nad\'ia mayor complejidad, ``oscuridad" y requisitos a la 
implementaci\'on. Ya que habr\'ia que tener instalada una base de datos MongoDB, as\'i como los conectores para
C\#.

As\'i que se decidi\'o ir por el camino de en medio y elegir un est\'andar que no requiriera de software adicional,
que fuese soportado de manera nativa por el lenguaje de programaci\'on y adem\'as f\'acilmente comprensible por
humanos. El elegido fue XML m\'as la biblioteca LINQ To XML incluida por defecto en .NET Framework. 

XML es un est\'andar recomendado por la W3C \cite{XML:Specification}, y la versi\'on actual es la 1.0 quinta edici\'on.
Por si mismo, XML no aporta ning\'un tipo de ventaja adicional respecto a las otras opciones, excepto el que no se
requiere de software adicional para compartir los datos de una aplicaci\'on a otra, y que
se pueden crear esquemas XSD para validar esos datos de manera muy sencilla. 
Lo que realmente marca
la diferencia es LINQ To XML.

LINQ To XML es una extensi\'on de la biblioteca LINQ (Language Integrated Query), que permite hacer consultas
similares a SQL a estructuras de datos .NET. Es posible obtener de un \emph{List<int>} todos aquellos n\'umeros
que sean menores que 5 y mayores que 10 con una sintaxis tan simple como la siguiente:

\begin{figure}[H]
	\begin{lstlisting}[tabsize=2, language=C, numbers=left, showspaces=false, breaklines=true]
		class IntroToLINQ
		{        
			static void Main()
			{
				// Las 3 partes de una consulta LINQ:
				//  1. Origen de datos.
				int[] numbers = new int[7] { 1, 5, 20, -4, 7, 8, 9};
				
				// 2. Creacion de la consulta.
				// numQuery es un IEnumerable<int>
				var numQuery =
					from num in numbers
					where (num < 5) && num > 10
					select num;
				
				// 3. Ejecucion de la consulta.
				foreach (int num in numQuery)
				{
					Console.Write("{0,1}", num);
				}
			}
		}
	\end{lstlisting}
	\caption[Consulta LINQ]{Consulta LINQ}
	\label{Consulta LINQ}
\end{figure}

En la Figura \ref{Consulta LINQ}
\footnote{Extra\'ida de \url{http://msdn.microsoft.com/en-us/library/vstudio/bb397906\%28v=vs.100\%29.aspx}}
se puede ver que con una sintaxis muy similar a SQL puede filtrarse un array en un momento.

El mismo concepto tiene LINQ to XML por lo que no es necesario explicarlo en mayor profundidad.

Una vez elegido el m\'etodo de guardado de datos, se llego a la tesitura de elegir una estructura para el XML.
Las dos opciones valoradas fueron las siguientes.

\subsection{Estructura XML 1}
\begin{figure}[H]
	\lstinputlisting[tabsize=2, language=XML, numbers=left]{./Attachments/Adjunto1.xml}
	\caption[Estructura XML 1]{Estructura XML 1}
	\label{Estructura XML1}
\end{figure}


Como se puede observar, el acercamiento sugerido es, que por cada instante de simulaci\'{o}n guardemos las observaciones que 
est\'{a}n teniendo lugar,
y los valores de las propiedades que tienen en ese instante.

Este formato, a la vista parece bueno, ya que se podr\'{i}a construir los gr\'{a}ficos instante a instante, todos a la vez. 
Pero, Â¿Y si se quiere
obtener el valor de una propiedad en concreto para mostrar todo el gr\'{a}fico de golpe? No se obtiene de manera directa, ya que 
habr\'{i}a que ciclar
a trav\'{e}s de todos los nodos instante, y a trav\'{e}s de todos los nodos observaci\'{o}n, buscando la propiedad deseada. 

N\'{o}tese que en distintas observaciones puede haber propiedades que tengan el mismo nombre, aumentando de complejidad la 
b\'{u}squeda.

\subsection{Estructura XML 2}
\begin{figure}[H]
	\lstinputlisting[tabsize=2, language=XML, numbers=left]{./Attachments/Adjunto2.xml}
	\caption[Estructura XML 2]{Estructura XML 2}
	\label{Estructura XML2}
\end{figure}

En este segundo ejemplo, de un simple vistazo podemos determinar todos los valores que va a tomar una propiedad de una 
observaci\'{o}n en concreto,
sin ning\'{u}n tipo de iteraci\'{o}n. En el nodo \emph{<data>} se ha a\~{n}adido un nuevo atributo \emph{instantLength} que 
determina la longitud de un instante. 

Por ejemplo, en la propiedad \emph{prop14} se ve que los instantes no son consecutivos, por lo que el sistema sabe que el 
gr\'{a}fico debe ser cont\'inuo en ese punto, es decir, desde el punto (1, 4) no debe unirse al 
(3, 5). Esto es \'{u}til para saber si una propiedad esta sucediendo o no.

\section{Gesti\'{o}n del c\'{o}digo fuente}
Hasta ahora no se ha hablado de algo que bien no es parte del desarrollo, pero que igualmente es importante.

Hoy en d\'ia, todo proyecto debe tener alg\'un tipo de gesti\'on del c\'odigo fuente, para evitar perdida de datos, 
poder volver a versiones anteriores y tener una mejor noci\'on de que se ha cambiado si es un proyecto colaborativo.

En este caso, al ser un proyecto realizado por una \'unica persona, parec\'ia razonable utilizar alg\'un otro tipo
de sistema. Ya que Git, CVS o Subversion son piezas de software muy potentes y usadas a gran escala, pero requieren
de un tiempo de aprendizaje, teniendo adem\'as una curva de aprendizaje bastante pronunciada.

Por tanto se valor\'o la posibilidad de utilizar Dropbox como sistema de gesti\'on y sincronizado del c\'odigo fuente.
Pero los problemas no tardaron en aflorar con cuestiones del tipo:

Â¿Qu\'e pasar\'ia si quiero volver a una versi\'on que hice hace 20 d\'ias? Â¿C\'omo creo un trabajo derivado a partir
de una versi\'on concreta? Por lo que finalmente se decidi\'o usar GIT, ya que incluso con la curva de aprendizaje,
es una herramienta muy potente y \'util, en la que se puede ver f\'acilmente que se hizo cierto d\'ia, o volver sin 
ning\'un problema a lo que se hizo ayer, o a lo que se hizo el primer d\'ia de proyecto.

Crear una nueva rama de desarrollo a partir de cualquier versi\'on es muy \'util y pr\'actico, por ejemplo, para
realizar pruebas experimentales sin romper el trabajo estable que se ha realizado hasta el momento. Tambi\'en
ha sido fruto de diversos problemas, pero nada que el manual oficial o stackoverflow no pudieran
resolver en unos minutos.

\section{Creaci\'{o}n de la documentaci\'{o}n}
Aunque esta secci\'{o}n pueda parecer una elecci\'{o}n obvia, trajo bastantes quebraderos de cabeza. Por un lado
se quer\'{i}a algo que no requiriera
de un estudio previo de 3 meses, que fuese lo suficientemente potente, que su rendimiento no decreciera seg\'{u}n aumentaban las 
p\'{a}ginas, y desde luego,
que pudiera editar tanto desde Windows, como Linux.

C\'{o}mo el proyecto lo estaba realizando en Windows, y para Windows Microsoft Office, parec\'{i}a la elecci\'{o}n obvia. Un 
producto potente muy bien integrado
en Windows, que permite crear documentos muy vistosos de manera muy sencilla. 
Pese a solo tener versiones oficiales de Windows y Mac OSX en Linux
funciona razonablemente bien utilizando WINE. Pero cuanto mas largo es un documento, el programa cada vez reacciona
mas lento, siendo complicado trabajar con documentos largos o con un dise\~no complejo.

Tambi\'en se valor\'o la posibilidad de usar LibreOffice u OpenOffice, por ser multiplataforma, pero adolecen
de las mismas limitaciones que Office. En ambas suites la colocaci\'on de im\'agenes y tablas puede ser como poco,
intrincado, pudiendo destrozar por completo el dise\~no del documento por querer mover medio cent\'imetro una tabla a la
derecha.

La \'ultima opci\'on valorada, y en la que este documento est\'a escrito ha sido \LaTeX.
Software de composici\'{o}n de textos creado por Donald E. Knuth \footnote{\url{http://www-cs-faculty.stanford.edu/~uno/}} 
muy popular entre los cient\'{i}ficos. Ofrece una manera similar de crear documentos a HTML 
aunque deber\'{i}a decirse al rev\'{e}s, ya que \LaTeX es bastante mas antiguo.

Para sacarle todo el partido se requiere un buen editor, con resaltado de sintaxis y autocompletado, 
la opci\'on elegida ha sido TexStudio, un
software de c\'{o}digo abierto que ofrece todo tipo de facilidades, multiplataforma.

All\'a donde el resto de software de edici\'on de textos fracasa, LaTeX resalta. Los ficheros, al ser de texto plano,
pueden integrarse en el software de control de versiones. El escritor puede abstraerse completamente del formato
y centrarse en escribir.

Tambi\'en es necesario decir, que pese a que la documentaci\'on ha sido escrita principalmente en LaTeX, algunas figuras
y gr\'aficos han sido creados con otras herramientas, entre ellas LibreOffice y Microsoft Word 2010.
